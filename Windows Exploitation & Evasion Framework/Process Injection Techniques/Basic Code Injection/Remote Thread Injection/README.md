# Remote Thread Injection
***Remote Thread Injection** is a process injection technique where an attacker creates a **new thread inside a remote process** to execute **malicious code** within its address space.
This method allows an attacker to execute arbitrary code in the context of a legitimate process, often to bypass security mechanisms like **EDR (Endpoint Detection & Response) and AV (Antivirus)**.*

## Why Use Remote Thread Injection?

- **Stealth & Evasion** – The malicious code runs inside a legitimate process, reducing detection chances.
- **Privilege Escalation** – Injecting into a higher-privileged process allows executing code with elevated rights.
- **Bypassing Security** – Many security tools monitor standalone processes but might ignore activity inside trusted ones.
- **Persistence** – Attackers can inject into system processes that run persistently (e.g., ```explorer.exe```, ```lsass.exe```).

# How Remote Thread Injection Works
*This technique involves four key steps:*

### 1. Find the Target Process
*The attacker identifies a running process to inject into. Common targets include:*

- ```explorer.exe``` – Persistent, often ignored by security tools.
- ```svchost.exe``` – Hosts system services, making detection harder.
- ```lsass.exe``` – Stores credentials (but is more monitored by security solutions).

***Example: Finding the Process ID (PID)***
```
DWORD GetProcessID(const char* processName) {
    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    PROCESSENTRY32 pe;
    pe.dwSize = sizeof(PROCESSENTRY32);

    if (Process32First(hSnap, &pe)) {
        do {
            if (!strcmp(pe.szExeFile, processName)) {
                CloseHandle(hSnap);
                return pe.th32ProcessID;
            }
        } while (Process32Next(hSnap, &pe));
    }
    CloseHandle(hSnap);
    return 0;
}
```

### 2. Allocate Memory in the Target Process
*Once the target process is found, memory is allocated inside it using ```VirtualAllocEx()```.*

***Example: Allocating Space in Remote Process***

```HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL);```

# Diagram of Remote Thread Injection
```
        ┌─────────────────────┐
        │ Attacker (Injector) │
        └───────────┬─────────┘
                    │
                    ▼
        ┌─────────────────────────────┐
        │ Target Process (Legitimate) │
        │ - Allocated Memory          │◄── [1] VirtualAllocEx()
        │ - Malicious Code Stored     │◄── [2] WriteProcessMemory()
        │ - Executing Malicious Code  │◄── [3] CreateRemoteThread()
        └─────────────────────────────┘
```

# Defense Against Remote Thread Injection
## Behavioral Detection
- **Monitor API Calls** – Flag suspicious usage of ```VirtualAllocEx()```, ```WriteProcessMemory()```, and ```CreateRemoteThread()```.
- **Track Inter-Process Memory Writes** – Watch for unauthorized memory modifications across processes.
- **Detect Unusual Thread Creation** – Identify new threads running outside their parent process.

## Mitigation Strategies
- **Enable Code Integrity Policies** – Prevent unsigned or untrusted code execution.
- **Use EDR Solutions** – Advanced security tools can detect unusual thread behavior.
- **Restrict Process Privileges** – Limit which processes can allocate memory in others.
- **Harden LSASS & Critical Processes** – Use ```Credential Guard``` to protect sensitive processes.
